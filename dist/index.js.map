{"version":3,"sources":["../src/index.js"],"names":["md5","require","fs","path","getHashedFilename","key","simpleCache","dirPath","init","dpath","existsSync","mkdirSync","set","value","Promise","resolve","reject","hashFilename","writeFile","join","JSON","stringify","err","cachedFile","data","get","readFile","parse","toString","isCached","access","constants","F_OK","isCachedSync","delete","unlink","deleteSync","unlinkSync","deleteAll","rmdir","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const md5 = require('md5')\r\nconst fs = require('fs')\r\nconst path = require('path')\r\n\r\nconst getHashedFilename = (key) => md5(key) + '.cache'\r\n\r\nfunction simpleCache() {\r\n\t\r\n\tthis.dirPath = ''\r\n\r\n\t/**\r\n\t * initialise the simpleCache instance\r\n\t * @param {string} dpath - path to the cache directory\r\n\t * @return {simpleCache} this instance\r\n\t */\r\n\tthis.init = (dpath) => {\r\n\t\tthis.dirPath = dpath\r\n\t\tif(!fs.existsSync(dpath)) {\r\n\t\t\tfs.mkdirSync(dpath)\r\n\t\t}\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * sets a key-value pair in a file in the cache directory\r\n\t * @param {string} key - Unique identifier\r\n\t * @param {dynamic} value - JSON serializable data\r\n\t * @return {Promise} resolves into object containing cached file info\r\n\t */\r\n\tthis.set = (key, value) => {\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tvar hashFilename = getHashedFilename(key)\r\n\t\t\tfs.writeFile(path.join(this.dirPath, hashFilename), JSON.stringify(value), (err) => {\r\n\t\t\t\tif(err) reject(err)\r\n\t\t\t\tvar cachedFile = {\r\n\t\t\t\t\tkey,\r\n\t\t\t\t\thashFilename,\r\n\t\t\t\t\tdata: value\r\n\t\t\t\t}\r\n\t\t\t\tresolve(cachedFile)\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * gets the value given a key by looking up for the corresponding file in the cache directory\r\n\t * @param {string} key - Unique identifier\r\n\t * @return {Promise} resolves into object containing cached file info\r\n\t */\r\n\tthis.get = (key) => {\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tvar hashFilename = getHashedFilename(key)\r\n\t\t\tfs.readFile(path.join(this.dirPath, hashFilename), (err, data) => {\r\n\t\t\t\tif(err) return reject(err)\r\n\t\t\t\tvar cachedFile = {\r\n\t\t\t\t\tkey,\r\n\t\t\t\t\thashFilename,\r\n\t\t\t\t\tdata: JSON.parse(data.toString())\r\n\t\t\t\t}\r\n\t\t\t\tresolve(cachedFile)\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * asynchronously checks if the file with the given key is cached in the cache directory\r\n\t * @param {string} key - Unique identifier\r\n\t * @return {Promise} boolean\r\n\t */\r\n\tthis.isCached = (key) => {\r\n\t\treturn new Promise((resolve) => {\r\n\t\t\tvar hashFilename = getHashedFilename(key)\r\n\t\t\tfs.access(path.join(this.dirPath, hashFilename), fs.constants.F_OK, (err) => {\r\n\t\t\t\tresolve(!err)\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * synchronous version of isCached\r\n\t * @param {string} key - Unique identifier\r\n\t * @return boolean\r\n\t */\r\n\tthis.isCachedSync = (key) => {\r\n\t\tvar hashFilename = getHashedFilename(key)\r\n\t\treturn fs.existsSync(path.join(this.dirPath, hashFilename))\r\n\t}\r\n\r\n\t/**\r\n\t * deletes the file associated with the given key\r\n\t * @param {string} key - Unique identifier\r\n\t * @return {Promise} resolves to true if successful\r\n\t */\r\n\tthis.delete = (key) => {\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tvar hashFilename = getHashedFilename(key)\r\n\t\t\tfs.unlink(path.join(this.dirPath, hashFilename), (err) => {\r\n\t\t\t\tif(err) return reject(err)\r\n\t\t\t\tresolve(true)\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * synchronous version of delete\r\n\t * @param {string} key - Unique identifier\r\n\t * @return {void}\r\n\t */\r\n\tthis.deleteSync = (key) => {\r\n\t\tvar hashFilename = getHashedFilename(key)\r\n\t\tfs.unlinkSync(hashFilename)\r\n\t}\r\n\r\n\t/**\r\n\t * asynchronously deletes cache directory\r\n\t * @return {Promise} resolves to true if successful\r\n\t */\r\n\tthis.deleteAll = () => {\r\n\t\treturn Promise((resolve, reject) => {\r\n\t\t\tfs.rmdir(this.dirPath, (err) => {\r\n\t\t\t\tif(err) return reject(err)\r\n\t\t\t\tresolve(true)\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n}\r\n\r\nmodule.exports = simpleCache"]}